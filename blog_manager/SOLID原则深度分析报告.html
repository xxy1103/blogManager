<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>博客管理系统 - SOLID原则深度分析报告</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            margin: 10px 0 0 0;
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .principle-section {
            background: white;
            margin: 30px 0;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border-left: 6px solid;
        }
        
        .srp { border-left-color: #e74c3c; }
        .ocp { border-left-color: #3498db; }
        .lsp { border-left-color: #2ecc71; }
        .isp { border-left-color: #f39c12; }
        .dip { border-left-color: #9b59b6; }
        
        .principle-title {
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
            font-size: 1.8em;
        }
        
        .definition {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #6c757d;
        }        .code-block {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            color: #f1f5f9;
            padding: 25px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
            font-size: 0.85em;
            line-height: 1.6;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            border: 1px solid #475569;
            position: relative;
            white-space: pre;
            word-wrap: break-word;
            tab-size: 4;
        }
        
        .code-block code {
            display: block;
            white-space: pre-wrap;
            word-break: break-word;
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
            color: inherit;
        }
        
        .code-block::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #ec4899, #f59e0b);
            border-radius: 12px 12px 0 0;
        }
        
        .code-block:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        
        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .code-title {
            background: #475569;
            color: #f8fafc;
            padding: 8px 15px;
            margin: -25px -25px 15px -25px;
            border-radius: 12px 12px 0 0;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid #64748b;
        }
        
        .mermaid-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            margin: 20px 0;
            text-align: center;
        }
          .example-card {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid #e2e8f0;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }
        
        .example-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
        }
        
        .example-title {
            color: #1e293b;
            font-weight: 700;
            margin-bottom: 15px;
            font-size: 1.15em;
            padding: 10px 15px;
            background: linear-gradient(135deg, #ddd6fe 0%, #c7d2fe 100%);
            border-radius: 8px;
            border-left: 4px solid #8b5cf6;
        }
        
        .example-card h4 {
            color: #475569;
            font-weight: 600;
            margin: 25px 0 12px 0;
            font-size: 1.05em;
            padding: 8px 12px;
            background: #f1f5f9;
            border-radius: 6px;
            border-left: 3px solid #3b82f6;
        }
        
        .benefits {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .challenges {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .highlight {
            background: #fff3cd;
            padding: 3px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .toc {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        
        .toc h2 {
            color: #2c3e50;
            margin-top: 0;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .toc ul {
            list-style: none;
            padding-left: 0;
        }
        
        .toc li {
            margin: 8px 0;
            padding: 8px 15px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        
        .toc li:hover {
            background-color: #f8f9fa;
        }
        
        .toc a {
            text-decoration: none;
            color: #495057;
            font-weight: 500;
        }
        
        .toc a:hover {
            color: #007bff;
        }
        
        .summary {
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin: 40px 0;
            text-align: center;
        }
        
        .summary h2 {
            margin-top: 0;
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🏛️ SOLID原则深度分析报告</h1>
        <p>博客管理系统中五大面向对象设计原则的设计思想与实现分析</p>
        <p>基于Spring Boot + MVC架构的实际应用案例</p>
    </div>

    <div class="toc">
        <h2>📋 目录</h2>
        <ul>
            <li><a href="#srp">🎯 单一职责原则 (SRP)</a></li>
            <li><a href="#ocp">🔓 开闭原则 (OCP)</a></li>
            <li><a href="#lsp">🔄 里氏替换原则 (LSP)</a></li>
            <li><a href="#isp">🎭 接口隔离原则 (ISP)</a></li>
            <li><a href="#dip">🔄 依赖倒置原则 (DIP)</a></li>
            <li><a href="#summary">📊 综合总结</a></li>
        </ul>
    </div>

    <div id="srp" class="principle-section srp">
        <h2 class="principle-title">🎯 单一职责原则 (Single Responsibility Principle, SRP)</h2>
        
        <div class="definition">
            <h3>🎯 原则定义</h3>
            <p><strong>一个类应该只有一个引起它变化的原因</strong>，即一个类只应该有一个职责。每个类都应该专注于做好一件事情。</p>
        </div>

        <div class="mermaid-container">
            <div class="mermaid">
                graph TB
                    subgraph "SRP实现架构"
                        Controller[BlogController<br/>职责：处理HTTP请求响应]
                        Service[BlogFileService<br/>职责：文件操作业务逻辑]
                        Model[Blog Model<br/>职责：数据模型定义]
                        Config[ConfigService<br/>职责：配置管理]
                        LLM[LLM Service<br/>职责：AI模型调用]
                    end
                    
                    Controller --> Service
                    Controller --> Config
                    Controller --> LLM
                    Service --> Model
                    
                    style Controller fill:#e74c3c,color:#fff
                    style Service fill:#3498db,color:#fff
                    style Model fill:#2ecc71,color:#fff
                    style Config fill:#f39c12,color:#fff
                    style LLM fill:#9b59b6,color:#fff
            </div>
        </div>

        <div class="example-card">
            <div class="example-title">💡 项目中的SRP实现示例</div>
            
            <h4>1. BlogController - 专注于HTTP请求处理</h4>            <div class="code-block">@RestController
@RequestMapping("/api/blogs")
public class BlogController {
    // 单一职责：仅处理HTTP请求和响应
    @GetMapping
    public ResponseEntity&lt;List&lt;Blog&gt;&gt; getAllBlogs() { ... }
    
    @PostMapping
    public ResponseEntity&lt;Blog&gt; createBlog(@RequestBody Blog blog) { ... }
    
    @DeleteMapping("/{filename}")
    public ResponseEntity&lt;String&gt; deleteBlog(@PathVariable String filename) { ... }
}</div>

            <h4>2. BlogFileService - 专注于文件操作业务逻辑</h4>            <div class="code-block">@Service
public class BlogFileService {
    // 单一职责：文件系统操作和博客数据管理
    public List&lt;Blog&gt; getAllBlogs() throws IOException { ... }
    
    public void saveBlog(Blog blog) throws IOException { ... }
    
    public void deleteBlog(String filename) throws IOException { ... }
    
    private Blog parseMarkdownFile(Path filePath) throws IOException { ... }
}</div>

            <h4>3. ConfigService - 专注于配置管理</h4>            <div class="code-block">@Configuration
public class ConfigService {
    // 单一职责：应用程序配置的加载、验证和管理
    @PostConstruct
    public void loadConfig() { ... }
    
    public Config getConfig() { return config; }
    
    public void saveConfig(Config config) throws IOException { ... }
    
    private void validateConfig(Config config) { ... }
}</div>
        </div>

        <div class="benefits">
            <h4>✅ SRP在项目中的优势体现</h4>
            <ul>
                <li><strong>高内聚</strong>：每个类的功能高度集中，如BlogController只处理Web层逻辑</li>
                <li><strong>易维护</strong>：修改文件操作逻辑只需改BlogFileService，不影响Controller</li>
                <li><strong>可测试</strong>：每个类都可以独立进行单元测试</li>
                <li><strong>职责明确</strong>：开发者可以快速定位功能模块</li>
            </ul>
        </div>

        <div class="challenges">
            <h4>⚠️ 设计挑战与注意事项</h4>
            <ul>
                <li><strong>粒度控制</strong>：避免过度拆分导致类过多</li>
                <li><strong>依赖管理</strong>：多个类之间需要合理的依赖注入</li>
                <li><strong>功能边界</strong>：需要准确划分每个类的职责边界</li>
            </ul>
        </div>
    </div>

    <div id="ocp" class="principle-section ocp">
        <h2 class="principle-title">🔓 开闭原则 (Open-Closed Principle, OCP)</h2>
        
        <div class="definition">
            <h3>🔓 原则定义</h3>
            <p><strong>软件实体应该对扩展开放，对修改封闭</strong>。即在不修改现有代码的前提下，通过扩展来实现新功能。</p>
        </div>

        <div class="mermaid-container">
            <div class="mermaid">
                graph TB
                    subgraph "LLM扩展架构体现OCP"
                        LLMInterface[LLM抽象类<br/>定义统一接口]
                        BigModel[BigModel实现<br/>智谱AI模型]
                        XModel[XModel实现<br/>预留扩展]
                        NewModel[新模型实现<br/>无需修改现有代码]
                        
                        Factory[LLM工厂模式<br/>支持动态创建]
                        FactoryInterface[FactoryInterface<br/>工厂抽象接口]
                        BigModelFactory[BigModelFactory<br/>具体工厂实现]
                        XModelFactory[XModelFactory<br/>扩展工厂实现]
                    end
                    
                    LLMInterface --> BigModel
                    LLMInterface --> XModel
                    LLMInterface -.-> NewModel
                    
                    FactoryInterface --> BigModelFactory
                    FactoryInterface --> XModelFactory
                    
                    Factory --> FactoryInterface
                    BigModelFactory --> BigModel
                    XModelFactory --> XModel
                    
                    style LLMInterface fill:#3498db,color:#fff
                    style NewModel fill:#e74c3c,color:#fff,stroke-dasharray: 5 5
                    style FactoryInterface fill:#2ecc71,color:#fff
            </div>
        </div>

        <div class="example-card">
            <div class="example-title">💡 项目中的OCP实现示例</div>
            
            <h4>1. LLM抽象基类 - 对扩展开放</h4>            <div class="code-block">public abstract class LLM {
    protected String APIKey;
    protected String APIUrl;
    protected String model;
    protected ArrayList&lt;POSTMessage&gt; messagesArray;
    
    public LLM(String APIKey, String APIUrl, String model) {
        // 基础功能实现
    }
    
    // 抽象方法：对扩展开放
    public abstract void callLLM(String prompt, String content, StreamCallback callback);
    
    // 通用方法：对修改封闭
    public String getAPIKey() { return APIKey; }
    public void setAPIKey(String APIKey) { this.APIKey = APIKey; }
}</div>

            <h4>2. BigModel具体实现 - 扩展而非修改</h4>
            <div class="code-block">
public class BigModel extends LLM {
    private static final Logger logger = LoggerFactory.getLogger(BigModel.class);
    
    public BigModel(String APIKey, String APIUrl, String model) {
        super(APIKey, APIUrl, model);  // 复用基类功能
    }
    
    @Override
    public void callLLM(String prompt, String content, StreamCallback callback) {
        // 智谱AI特定的实现逻辑
        // 无需修改LLM基类
        try {
            POSTMessage message = new POSTMessage("user", prompt + content);
            // ... 具体实现
        } catch (Exception e) {
            callback.onError("调用LLM时发生错误: " + e.getMessage());
        }
    }
}
            </div>

            <h4>3. 工厂模式支持 - 扩展新模型</h4>
            <div class="code-block">
public interface FactoryInterface {
    LLM createLLM(String APIKey, String APIUrl, String model);
}

public class BigModelFactory implements FactoryInterface {
    @Override
    public LLM createLLM(String APIKey, String APIUrl, String model) {
        return new BigModel(APIKey, APIUrl, model);
    }
}

// 新增模型时，只需添加新的工厂实现，无需修改现有代码
public class NewAIModelFactory implements FactoryInterface {
    @Override
    public LLM createLLM(String APIKey, String APIUrl, String model) {
        return new NewAIModel(APIKey, APIUrl, model);
    }
}
            </div>
        </div>

        <div class="benefits">
            <h4>✅ OCP在项目中的优势体现</h4>
            <ul>
                <li><strong>扩展性强</strong>：新增AI模型无需修改现有LLM代码</li>
                <li><strong>稳定性好</strong>：现有功能不受新功能影响</li>
                <li><strong>维护简单</strong>：新功能独立开发和测试</li>
                <li><strong>向后兼容</strong>：系统升级不破坏现有功能</li>
            </ul>
        </div>

        <div class="challenges">
            <h4>⚠️ 设计挑战与注意事项</h4>
            <ul>
                <li><strong>抽象设计</strong>：需要合理设计抽象接口，预判扩展需求</li>
                <li><strong>性能考虑</strong>：抽象层可能带来轻微的性能开销</li>
                <li><strong>复杂度管理</strong>：过度抽象会增加系统复杂度</li>
            </ul>
        </div>
    </div>

    <div id="lsp" class="principle-section lsp">
        <h2 class="principle-title">🔄 里氏替换原则 (Liskov Substitution Principle, LSP)</h2>
        
        <div class="definition">
            <h3>🔄 原则定义</h3>
            <p><strong>子类对象应该能够替换其基类对象而不改变程序的正确性</strong>。即所有引用基类的地方必须能够透明地使用其子类的对象。</p>
        </div>

        <div class="mermaid-container">
            <div class="mermaid">
                graph TB
                    subgraph "LSP在LLM架构中的体现"
                        Client[Controller客户端<br/>使用LLM抽象类]
                        LLMBase[LLM抽象基类<br/>定义契约规范]
                        
                        subgraph "可替换的具体实现"
                            BigModel[BigModel<br/>智谱AI实现]
                            XModel[XModel<br/>其他AI实现]
                            FutureModel[未来AI模型<br/>完全可替换]
                        end
                        
                        CallbackInterface[StreamCallback接口<br/>回调契约]
                        CallbackImpl[具体回调实现<br/>遵循接口契约]
                    end
                    
                    Client --> LLMBase
                    LLMBase --> BigModel
                    LLMBase --> XModel
                    LLMBase -.-> FutureModel
                    
                    BigModel --> CallbackInterface
                    XModel --> CallbackInterface
                    CallbackInterface --> CallbackImpl
                    
                    style Client fill:#e74c3c,color:#fff
                    style LLMBase fill:#2ecc71,color:#fff
                    style FutureModel fill:#9b59b6,color:#fff,stroke-dasharray: 5 5
                    style CallbackInterface fill:#f39c12,color:#fff
            </div>
        </div>

        <div class="example-card">
            <div class="example-title">💡 项目中的LSP实现示例</div>
            
            <h4>1. LLM基类定义行为契约</h4>
            <div class="code-block">
public abstract class LLM {
    // 契约：构造函数必须接受这三个参数
    public LLM(String APIKey, String APIUrl, String model) {
        this.APIKey = APIKey;
        this.APIUrl = APIUrl;
        this.model = model;
        this.messagesArray = new ArrayList&lt;&gt;();
    }
    
    // 契约：所有子类必须实现此方法，且行为语义一致
    /**
     * 调用 LLM 的 API 接口
     * @param prompt 提示词
     * @param content 内容
     * @param callback 流式输出回调接口
     * 契约保证：必须调用callback的onResponse或onError方法
     */
    public abstract void callLLM(String prompt, String content, StreamCallback callback);
    
    // 契约：所有子类继承相同的属性访问行为
    public String getAPIKey() { return APIKey; }
    public void setAPIKey(String APIKey) { this.APIKey = APIKey; }
}
            </div>

            <h4>2. BigModel遵循LSP实现</h4>
            <div class="code-block">
public class BigModel extends LLM {
    public BigModel(String APIKey, String APIUrl, String model) {
        super(APIKey, APIUrl, model);  // 遵循基类契约
    }
    
    @Override
    public void callLLM(String prompt, String content, StreamCallback callback) {
        try {
            // 实现具体逻辑，但遵循基类契约：
            // 1. 接受相同的参数
            // 2. 必须调用callback方法
            // 3. 异常情况调用callback.onError
            
            POSTMessage message = new POSTMessage("user", prompt + content);
            this.messagesArray.add(message);
            
            // ... HTTP请求处理 ...
            
            // 遵循契约：正常情况调用onResponse
            callback.onResponse(inputLine, isDone);
            
        } catch (Exception e) {
            // 遵循契约：异常情况调用onError
            callback.onError("调用LLM时发生错误: " + e.getMessage());
        }
    }
}
            </div>

            <h4>3. StreamCallback接口契约</h4>
            <div class="code-block">
public interface StreamCallback {
    /**
     * 处理流式输出的回调方法
     * 契约：chunk不为null，isDone表示是否完成
     */
    void onResponse(String chunk, boolean isDone);
    
    /**
     * 错误处理回调方法
     * 契约：error不为null且包含错误描述
     */
    void onError(String error);
}

// 在Controller中的使用 - 完全可替换
public void processLLMRequest(LLM llmInstance) {
    // 无论传入BigModel还是XModel，都能正常工作
    llmInstance.callLLM(prompt, content, new StreamCallback() {
        @Override
        public void onResponse(String chunk, boolean isDone) {
            // 处理响应
        }
        
        @Override
        public void onError(String error) {
            // 处理错误
        }
    });
}
            </div>
        </div>

        <div class="benefits">
            <h4>✅ LSP在项目中的优势体现</h4>
            <ul>
                <li><strong>完全可替换</strong>：BigModel和XModel在客户端代码中完全可互换</li>
                <li><strong>行为一致性</strong>：所有LLM实现都遵循相同的调用契约</li>
                <li><strong>多态支持</strong>：支持运行时动态选择不同的AI模型</li>
                <li><strong>测试友好</strong>：可以用Mock对象替换真实实现进行测试</li>
            </ul>
        </div>

        <div class="challenges">
            <h4>⚠️ 设计挑战与注意事项</h4>
            <ul>
                <li><strong>契约设计</strong>：基类契约需要兼顾所有子类的实现需求</li>
                <li><strong>行为语义</strong>：不仅要语法正确，还要保证语义行为一致</li>
                <li><strong>异常处理</strong>：子类的异常处理方式应与基类期望一致</li>
            </ul>
        </div>
    </div>

    <div id="isp" class="principle-section isp">
        <h2 class="principle-title">🎭 接口隔离原则 (Interface Segregation Principle, ISP)</h2>
        
        <div class="definition">
            <h3>🎭 原则定义</h3>
            <p><strong>不应该强迫客户端依赖它们不使用的接口</strong>。应该使用多个专门的接口，而不是单一的总接口。</p>
        </div>

        <div class="mermaid-container">
            <div class="mermaid">
                graph TB
                    subgraph "ISP接口隔离设计"
                        subgraph "专门化接口"
                            StreamCallback[StreamCallback<br/>流式回调专用接口]
                            FactoryInterface[FactoryInterface<br/>工厂创建专用接口]
                            ConfigInterface[配置管理接口<br/>专注配置操作]
                        end
                        
                        subgraph "客户端按需依赖"
                            LLMClient[LLM客户端<br/>只依赖StreamCallback]
                            FactoryClient[工厂客户端<br/>只依赖FactoryInterface]
                            ConfigClient[配置客户端<br/>只依赖Config接口]
                        end
                        
                        subgraph "具体实现"
                            CallbackImpl[回调具体实现]
                            BigModelFactory[BigModel工厂实现]
                            ConfigService[配置服务实现]
                        end
                    end
                    
                    LLMClient --> StreamCallback
                    FactoryClient --> FactoryInterface
                    ConfigClient --> ConfigInterface
                    
                    StreamCallback --> CallbackImpl
                    FactoryInterface --> BigModelFactory
                    ConfigInterface --> ConfigService
                    
                    style StreamCallback fill:#e74c3c,color:#fff
                    style FactoryInterface fill:#3498db,color:#fff
                    style ConfigInterface fill:#2ecc71,color:#fff
            </div>
        </div>

        <div class="example-card">
            <div class="example-title">💡 项目中的ISP实现示例</div>
            
            <h4>1. StreamCallback - 专门的流式回调接口</h4>
            <div class="code-block">
/**
 * 流式输出回调接口
 * 专门用于处理LLM API的流式响应
 * 符合ISP：只包含流式处理相关的方法
 */
public interface StreamCallback {
    /**
     * 处理流式输出的回调方法
     */
    void onResponse(String chunk, boolean isDone);
    
    /**
     * 错误处理回调方法
     */
    void onError(String error);
    
    // 不包含其他无关方法，如文件操作、配置管理等
}
            </div>

            <h4>2. FactoryInterface - 专门的工厂创建接口</h4>
            <div class="code-block">
/**
 * LLM工厂接口
 * 专门用于创建LLM实例
 * 符合ISP：只包含对象创建相关的方法
 */
public interface FactoryInterface {
    /**
     * 创建LLM实例的专门方法
     */
    LLM createLLM(String APIKey, String APIUrl, String model);
    
    // 不包含其他职责，如配置管理、数据处理等
}

// BigModelFactory只需实现对象创建功能
public class BigModelFactory implements FactoryInterface {
    @Override
    public LLM createLLM(String APIKey, String APIUrl, String model) {
        return new BigModel(APIKey, APIUrl, model);
    }
    
    // 无需实现无关的接口方法
}
            </div>

            <h4>3. 避免胖接口的设计</h4>
            <div class="code-block">
// ❌ 违反ISP的胖接口设计（项目中避免了这种设计）
/*
public interface LLMServiceInterface {
    // LLM调用相关
    void callLLM(String prompt, String content, StreamCallback callback);
    
    // 配置管理相关 - 违反ISP
    void loadConfig();
    void saveConfig();
    
    // 文件操作相关 - 违反ISP
    List&lt;Blog&gt; getAllBlogs();
    void saveBlog(Blog blog);
    
    // 日志管理相关 - 违反ISP
    void writeLog(String message);
    void clearLogs();
}
*/

// ✅ 符合ISP的接口设计（项目实际采用）
// 将功能分解为多个专门接口：

// LLM调用专用
public abstract class LLM {
    public abstract void callLLM(String prompt, String content, StreamCallback callback);
}

// 文件服务专用
@Service
public class BlogFileService {
    public List&lt;Blog&gt; getAllBlogs() { ... }
    public void saveBlog(Blog blog) { ... }
}

// 配置管理专用
@Configuration
public class ConfigService {
    public Config getConfig() { ... }
    public void saveConfig(Config config) { ... }
}
            </div>
        </div>

        <div class="benefits">
            <h4>✅ ISP在项目中的优势体现</h4>
            <ul>
                <li><strong>最小依赖</strong>：每个客户端只依赖它真正需要的接口方法</li>
                <li><strong>高度聚焦</strong>：接口职责单一，易于理解和实现</li>
                <li><strong>变更隔离</strong>：某个接口的变更不会影响其他无关客户端</li>
                <li><strong>实现简单</strong>：实现类无需提供无关功能的空实现</li>
            </ul>
        </div>

        <div class="challenges">
            <h4>⚠️ 设计挑战与注意事项</h4>
            <ul>
                <li><strong>接口粒度</strong>：需要合理控制接口的粒度，避免过度细分</li>
                <li><strong>接口数量</strong>：过多的小接口可能增加系统复杂性</li>
                <li><strong>职责划分</strong>：需要准确识别不同客户端的真实需求</li>
            </ul>
        </div>
    </div>

    <div id="dip" class="principle-section dip">
        <h2 class="principle-title">🔄 依赖倒置原则 (Dependency Inversion Principle, DIP)</h2>
        
        <div class="definition">
            <h3>🔄 原则定义</h3>
            <p><strong>高层模块不应该依赖低层模块，两者都应该依赖抽象；抽象不应该依赖具体实现，具体实现应该依赖抽象</strong>。</p>
        </div>

        <div class="mermaid-container">
            <div class="mermaid">
                graph TB
                    subgraph "依赖倒置架构"
                        subgraph "高层模块"
                            Controller[BlogController<br/>高层业务逻辑]
                            LLMController[LLMController<br/>AI调用控制器]
                        end
                        
                        subgraph "抽象层"
                            LLMAbstract[LLM抽象类<br/>定义AI调用契约]
                            ServiceInterface[Service接口<br/>业务逻辑抽象]
                            CallbackInterface[StreamCallback<br/>回调抽象]
                        end
                        
                        subgraph "低层模块/具体实现"
                            BigModel[BigModel<br/>智谱AI具体实现]
                            FileService[BlogFileService<br/>文件操作实现]
                            ConfigService[ConfigService<br/>配置管理实现]
                        end
                        
                        subgraph "依赖注入容器"
                            Spring[Spring Container<br/>IoC容器管理]
                        end
                    end
                    
                    Controller --> ServiceInterface
                    LLMController --> LLMAbstract
                    Controller --> CallbackInterface
                    
                    ServiceInterface --> FileService
                    LLMAbstract --> BigModel
                    CallbackInterface --> ConfigService
                    
                    Spring -.-> Controller
                    Spring -.-> FileService
                    Spring -.-> ConfigService
                    
                    style Controller fill:#e74c3c,color:#fff
                    style LLMAbstract fill:#3498db,color:#fff
                    style Spring fill:#f39c12,color:#fff
                    style ServiceInterface fill:#2ecc71,color:#fff
            </div>
        </div>

        <div class="example-card">
            <div class="example-title">💡 项目中的DIP实现示例</div>
            
            <h4>1. Controller依赖抽象而非具体实现</h4>
            <div class="code-block">
@RestController
@RequestMapping("/api/blogs")
public class BlogController {
    
    // ✅ 依赖抽象：通过Spring注入服务接口
    @Autowired
    private BlogFileService blogFileService;  // 依赖于服务抽象
    
    @Autowired 
    private ConfigService configService;      // 依赖于配置抽象
    
    // 高层模块不直接new具体实现类
    // ❌ private BlogFileService service = new BlogFileService();
    
    @GetMapping
    public ResponseEntity&lt;List&lt;Blog&gt;&gt; getAllBlogs() {
        try {
            // 调用抽象方法，不关心具体实现
            List&lt;Blog&gt; blogs = blogFileService.getAllBlogs();
            return ResponseEntity.ok(blogs);
        } catch (IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}
            </div>

            <h4>2. LLM抽象层实现依赖倒置</h4>
            <div class="code-block">
// 高层模块：LLMController
@RestController
@RequestMapping("/api/llm")
public class LLMController {
    
    public void processLLMRequest(String prompt, String content) {
        // 依赖抽象：通过工厂获取LLM实例
        FactoryInterface factory = getFactory(modelType);
        LLM llmInstance = factory.createLLM(apiKey, apiUrl, model);
        
        // 依赖回调抽象
        StreamCallback callback = new StreamCallback() {
            @Override
            public void onResponse(String chunk, boolean isDone) {
                // 处理响应
            }
            
            @Override  
            public void onError(String error) {
                // 处理错误
            }
        };
        
        // 调用抽象方法，不依赖具体实现
        llmInstance.callLLM(prompt, content, callback);
    }
}

// 抽象层：定义契约
public abstract class LLM {
    // 抽象方法：具体实现依赖此抽象
    public abstract void callLLM(String prompt, String content, StreamCallback callback);
}

// 低层模块：具体实现依赖抽象
public class BigModel extends LLM {
    @Override
    public void callLLM(String prompt, String content, StreamCallback callback) {
        // 具体实现依赖于StreamCallback抽象
        // 而不是依赖具体的回调实现类
        try {
            // ... 处理逻辑 ...
            callback.onResponse(response, true);  // 调用抽象方法
        } catch (Exception e) {
            callback.onError(e.getMessage());     // 调用抽象方法
        }
    }
}
            </div>

            <h4>3. Spring IoC容器支持依赖注入</h4>
            <div class="code-block">
// ConfigService使用@Configuration注解，成为Spring管理的Bean
@Configuration
public class ConfigService {
    private Config config;
    
    @PostConstruct
    public void loadConfig() {
        // 初始化配置
    }
    
    public Config getConfig() {
        return config;
    }
}

// BlogFileService使用@Service注解，由Spring容器管理
@Service  
public class BlogFileService {
    private final ConfigService configService;
    
    // 构造函数注入：依赖抽象配置服务
    @Autowired
    public BlogFileService(ConfigService configService) {
        this.configService = configService;
    }
    
    public List&lt;Blog&gt; getAllBlogs() throws IOException {
        // 使用注入的配置服务
        Config config = configService.getConfig();
        String blogDirectory = config.getBlogDirectory();
        // ... 具体实现 ...
    }
}

// Spring容器配置（application.properties）
# blog.directory=./blogs
# llm.api.key=${LLM_API_KEY}
# llm.api.url=${LLM_API_URL}
            </div>
        </div>

        <div class="benefits">
            <h4>✅ DIP在项目中的优势体现</h4>
            <ul>
                <li><strong>松耦合</strong>：高层模块不依赖具体实现，便于替换和测试</li>
                <li><strong>可测试性</strong>：可以轻松注入Mock对象进行单元测试</li>
                <li><strong>可扩展性</strong>：新增LLM模型或服务实现无需修改高层代码</li>
                <li><strong>配置灵活</strong>：通过Spring配置可以灵活切换实现</li>
            </ul>
        </div>

        <div class="challenges">
            <h4>⚠️ 设计挑战与注意事项</h4>
            <ul>
                <li><strong>抽象设计</strong>：需要设计合适的抽象层，避免过度抽象</li>
                <li><strong>容器依赖</strong>：依赖IoC容器增加了框架复杂性</li>
                <li><strong>运行时绑定</strong>：依赖关系在运行时确定，可能影响性能</li>
            </ul>
        </div>
    </div>

    <div id="summary" class="summary">
        <h2>📊 SOLID原则综合分析总结</h2>
        
        <div class="mermaid-container">
            <div class="mermaid">
                graph TB
                    subgraph "SOLID原则协同作用"
                        SRP[单一职责原则<br/>SRP]
                        OCP[开闭原则<br/>OCP]
                        LSP[里氏替换原则<br/>LSP]
                        ISP[接口隔离原则<br/>ISP]
                        DIP[依赖倒置原则<br/>DIP]
                        
                        Quality[代码质量提升<br/>可维护、可扩展、可测试]
                        
                        SRP --> Quality
                        OCP --> Quality
                        LSP --> Quality
                        ISP --> Quality
                        DIP --> Quality
                        
                        SRP -.-> OCP
                        OCP -.-> LSP
                        LSP -.-> ISP
                        ISP -.-> DIP
                        DIP -.-> SRP
                    end
                    
                    style Quality fill:#e74c3c,color:#fff
                    style SRP fill:#3498db,color:#fff
                    style OCP fill:#2ecc71,color:#fff
                    style LSP fill:#f39c12,color:#fff
                    style ISP fill:#9b59b6,color:#fff
                    style DIP fill:#e67e22,color:#fff
            </div>
        </div>

        <div style="background: rgba(255,255,255,0.9); padding: 25px; border-radius: 10px; margin: 20px 0; color: #2c3e50;">
            <h3>🎯 项目架构的SOLID实践成果</h3>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0;">
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #e74c3c;">
                    <h4 style="margin: 0 0 10px 0; color: #e74c3c;">🎯 SRP体现</h4>
                    <p style="margin: 0; font-size: 0.9em;">Controller专注请求处理、Service专注业务逻辑、Model专注数据结构</p>
                </div>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #3498db;">
                    <h4 style="margin: 0 0 10px 0; color: #3498db;">🔓 OCP体现</h4>
                    <p style="margin: 0; font-size: 0.9em;">LLM抽象类支持扩展新AI模型，工厂模式支持动态创建</p>
                </div>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #2ecc71;">
                    <h4 style="margin: 0 0 10px 0; color: #2ecc71;">🔄 LSP体现</h4>
                    <p style="margin: 0; font-size: 0.9em;">BigModel和XModel完全可替换，遵循相同的行为契约</p>
                </div>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #f39c12;">
                    <h4 style="margin: 0 0 10px 0; color: #f39c12;">🎭 ISP体现</h4>
                    <p style="margin: 0; font-size: 0.9em;">StreamCallback、FactoryInterface等专门化接口，避免胖接口</p>
                </div>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                    <h4 style="margin: 0 0 10px 0; color: #9b59b6;">🔄 DIP体现</h4>
                    <p style="margin: 0; font-size: 0.9em;">Spring IoC实现依赖注入，高层模块依赖抽象而非具体实现</p>
                </div>
            </div>
            
            <h3>✨ 架构优势总结</h3>
            <ul style="column-count: 2; column-gap: 30px; list-style: none; padding: 0;">
                <li style="margin: 8px 0; padding: 8px; background: rgba(52, 152, 219, 0.1); border-radius: 5px;">🚀 <strong>高可扩展性</strong>：新增功能无需修改现有代码</li>
                <li style="margin: 8px 0; padding: 8px; background: rgba(46, 204, 113, 0.1); border-radius: 5px;">🛡️ <strong>高可维护性</strong>：职责分离，变更影响范围小</li>
                <li style="margin: 8px 0; padding: 8px; background: rgba(155, 89, 182, 0.1); border-radius: 5px;">🧪 <strong>高可测试性</strong>：依赖注入支持Mock测试</li>
                <li style="margin: 8px 0; padding: 8px; background: rgba(243, 156, 18, 0.1); border-radius: 5px;">🔄 <strong>高复用性</strong>：抽象组件可在多处复用</li>
                <li style="margin: 8px 0; padding: 8px; background: rgba(231, 76, 60, 0.1); border-radius: 5px;">⚡ <strong>低耦合度</strong>：模块间依赖关系清晰</li>
                <li style="margin: 8px 0; padding: 8px; background: rgba(52, 152, 219, 0.1); border-radius: 5px;">🎯 <strong>高内聚性</strong>：每个类专注单一职责</li>
            </ul>
        </div>
    </div>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'base',
            themeVariables: {
                primaryColor: '#f8f9fa',
                primaryTextColor: '#2c3e50',
                primaryBorderColor: '#dee2e6',
                lineColor: '#6c757d',
                secondaryColor: '#e9ecef',
                tertiaryColor: '#f8f9fa'
            }
        });
    </script>
</body>
</html>
