<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>博客管理系统架构设计报告</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #495057;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
          .header {
            text-align: center;
            background: linear-gradient(135deg, #e3f2fd 0%, #f8f9fa 100%);
            color: #2c3e50;
            padding: 40px 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.05);
            border: 1px solid #e0e6ed;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            font-size: 1.2em;
            opacity: 0.9;
        }
          .section {
            background: white;
            margin: 30px 0;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.02);
            border-left: 5px solid #6c5ce7;
        }
        
        .section h2 {
            color: #6c5ce7;
            border-bottom: 2px solid #f8f9fa;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
          .section h3 {
            color: #495057;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
          .mermaid {
            background: white;
            border-radius: 8px;
            padding: 30px;
            margin: 25px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            min-height: 400px;
            overflow: visible;
        }
        
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
        }
          .pattern-card {
            background: #f0f7ff;
            border-left: 4px solid #74b9ff;
            padding: 20px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .pattern-card h4 {
            color: #6c5ce7;
            margin-top: 0;
            font-size: 1.2em;
        }
          .highlight {
            background: linear-gradient(120deg, #e8f5ff 0%, #f0f7ff 100%);
            padding: 3px 6px;
            border-radius: 4px;
            font-weight: 500;
            color: #6c5ce7;
        }
        
        .tech-stack {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
          .tech-item {
            background: linear-gradient(135deg, #74b9ff 0%, #a29bfe 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
            box-shadow: 0 4px 10px rgba(116, 185, 255, 0.2);
        }
          .advantages {
            background: #f0f9ff;
            border-left: 4px solid #74b9ff;
            padding: 20px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .summary-box {
            background: linear-gradient(135deg, #e3f2fd 0%, #f0f7ff 100%);
            color: #2c3e50;
            padding: 25px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
            border: 1px solid #e0e6ed;
        }
          .footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: #6c757d;
            font-size: 0.9em;
        }
        
        ul, ol {
            padding-left: 25px;
        }
        
        li {
            margin: 8px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>博客管理系统架构设计报告</h1>
        <p>基于Spring Boot的RESTful API博客后端系统</p>
        <p>架构分析 • 设计模式 • 系统设计</p>
    </div>

    <div class="section">
        <h2>1. 系统概述</h2>
        
        <h3>1.1 项目背景</h3>
        <p>该博客管理系统是一个基于<span class="highlight">Spring Boot 3.4.5</span>构建的后端API服务，采用标准的MVC架构模式，提供完整的博客文章管理功能，包括文章的增删改查、图片管理、配置管理以及LLM（大语言模型）集成等功能。</p>
        
        <h3>1.2 技术栈</h3>
        <div class="tech-stack">
            <div class="tech-item">Spring Boot 3.4.5</div>
            <div class="tech-item">Java 17</div>
            <div class="tech-item">Spring Web</div>
            <div class="tech-item">Spring WebFlux</div>
            <div class="tech-item">SnakeYAML</div>
            <div class="tech-item">Gson</div>
            <div class="tech-item">Maven</div>
        </div>
        
        <h3>1.3 系统特点</h3>
        <ul>
            <li><strong>RESTful API设计</strong>：遵循REST架构风格，提供标准化的HTTP接口</li>
            <li><strong>文件存储</strong>：采用本地文件系统存储，支持Markdown格式文章</li>
            <li><strong>配置管理</strong>：支持动态配置加载和更新</li>
            <li><strong>LLM集成</strong>：集成多种大语言模型API，支持智能内容生成</li>
            <li><strong>流式响应</strong>：支持Server-Sent Events(SSE)实现实时数据推送</li>
        </ul>
    </div>

    <div class="section">
        <h2>2. 系统架构分析</h2>
        
        <h3>2.1 整体架构图</h3>        <div class="mermaid">
flowchart TD
    A["`**客户端请求**`"] --> B["`**Spring Boot应用**`"]
    B --> C["`**Controller层**<br/>控制器`"]
    C --> D["`**Service层**<br/>业务逻辑`"]
    D --> E["`**Repository层**<br/>数据访问`"]
    E --> F["`**文件系统**<br/>存储`"]
    
    C --> G["`**LLM Service**<br/>AI服务`"]
    G --> H["`**外部LLM API**<br/>智谱AI/X-Model`"]
    
    C --> I["`**Config Service**<br/>配置管理`"]
    I --> J["`**配置文件**<br/>YAML`"]
      C --> K["`**Image Service**<br/>图片服务`"]
    K --> L["`**图片存储**<br/>静态资源`"]
    
    %% 样式定义
    classDef primaryNode fill:#e3f2fd,stroke:#74b9ff
    classDef controllerNode fill:#f0f7ff,stroke:#a29bfe
    classDef serviceNode fill:#e8f5ff,stroke:#6c5ce7
    classDef storageNode fill:#f0fdff,stroke:#74b9ff
    classDef externalNode fill:#f8f9fa,stroke:#b2bec3
    
    class A,B primaryNode
    class C controllerNode
    class D,G,I,K serviceNode
    class E,F,J,L storageNode
    class H externalNode
        </div>
        
        <h3>2.2 分层架构详解</h3>
        
        <div class="pattern-card">
            <h4>Controller层 (表现层)</h4>
            <p><strong>职责</strong>：处理HTTP请求，参数验证，响应格式化</p>
            <p><strong>组件</strong>：BlogController, ConfigController, ImageController, LLMController</p>
            <p><strong>特点</strong>：采用@RestController注解，支持RESTful API设计，统一返回Message对象</p>
        </div>
        
        <div class="pattern-card">
            <h4>Service层 (业务逻辑层)</h4>
            <p><strong>职责</strong>：业务逻辑处理，事务管理，业务规则实现</p>
            <p><strong>组件</strong>：ConfigService, LLM相关服务</p>
            <p><strong>特点</strong>：使用@Service注解，实现具体业务逻辑</p>
        </div>
        
        <div class="pattern-card">
            <h4>Repository层 (数据访问层)</h4>
            <p><strong>职责</strong>：数据持久化，文件操作，数据访问</p>
            <p><strong>组件</strong>：BlogFileService</p>
            <p><strong>特点</strong>：封装文件系统操作，提供数据访问接口</p>
        </div>
    </div>    <div class="section">
        <h2>3. 系统类关系分析</h2>
        
        <h3>3.1 完整系统类图</h3>
        <div class="mermaid">
classDiagram
    %% 控制器层
    class BlogController {
        -BlogFileService blogFileService
        -List~Blog~ blogList
        +listBlogFilenames() Message
        +returnBlogByPath(String) Message
        +updateBlogInfo(Blog) Message
        +updateBlogContent(Blog) Message
        +addBlog(Blog) Message
        +deleteBlog(String) Message
    }
    
    class LLMController {
        -FactoryInterface factory
        -ConfigService configService
        +streamGenerate(String) ResponseEntity
        +getPrompt(String) Message
    }
    
    class ConfigController {
        -ConfigService configService
        +getConfig() Message
        +updateConfig(Config) Message
    }
    
    class ImageController {
        -Path storageLocation
        +uploadImage(MultipartFile) Message
        +listImages() Message
    }
    
    %% 服务层
    class BlogFileService {
        -Path storageLocation
        -Config config
        +listPostFilenames() List~Blog~
        +savePost(Blog) void
        +deleteBlog(Blog) void
        +resolve(String) Path
        +init() void
    }
    
    class ConfigService {
        -Config config
        -String configPath
        +loadConfig() Config
        +saveConfig(Config) void
        +getConfig() Config
        +updateConfig(Config) void
    }
    
    %% 模型层
    class Blog {
        -Path filepath
        -String filename
        -String title
        -LocalDateTime dateTime
        -String categories
        -String tags
        -String saying
        -String content
        +loadContent() String
        +clone() Blog
        +compareTo(Blog) int
        +equals(Object) boolean
    }
    
    class Config {
        -String blogStoragePath
        -String imageStoragePath
        -String xmodelAPIKey
        -String bigmodelAPIKey
        +getBlogStoragePath() String
        +getImageStoragePath() String
    }
    
    class Message {
        -int status
        -Object data
        -String error
        +getStatus() int
        +getData() Object
        +getError() String
    }
    
    %% LLM相关类
    class LLM {
        <<abstract>>
        -String APIKey
        -String APIUrl
        -String model
        #ArrayList~POSTMessage~ messagesArray
        -Boolean IsStream
        -String temperature
        +callLLM(StreamCallback) void
        +getAPIKey() String
        +getAPIUrl() String
    }
    
    class BigModel {
        +callLLM(StreamCallback) void
        +sendRequest(String) String
    }
    
    class XModel {
        +callLLM(StreamCallback) void
        +sendRequest(String) String
    }
    
    class FactoryInterface {
        <<interface>>
        +createLLM() LLM
    }
    
    class BigModelFactory {
        +createLLM() LLM
    }
    
    class XModelFactory {
        +createLLM() LLM
    }
    
    class StreamCallback {
        <<interface>>
        +onNext(String) void
        +onError(Throwable) void
        +onComplete() void
    }
    
    class POSTMessage {
        -String role
        -String content
        +getRole() String
        +getContent() String
    }
    
    %% 关系定义
    BlogController --> BlogFileService : uses
    BlogController --> Blog : manages
    BlogController --> Message : returns
    BlogFileService --> Blog : creates
    BlogFileService --> Config : uses
    
    LLMController --> FactoryInterface : uses
    LLMController --> ConfigService : uses
    LLMController --> Message : returns
    
    ConfigController --> ConfigService : uses
    ConfigController --> Config : manages
    ConfigController --> Message : returns
    
    ConfigService --> Config : manages
    
    FactoryInterface <|.. BigModelFactory : implements
    FactoryInterface <|.. XModelFactory : implements
    
    LLM <|-- BigModel : extends
    LLM <|-- XModel : extends
    
    BigModelFactory --> BigModel : creates
    XModelFactory --> XModel : creates
    
    BigModel --> StreamCallback : uses
    XModel --> StreamCallback : uses
    BigModel --> POSTMessage : uses
    XModel --> POSTMessage : uses
    Blog ..|> Comparable : implements
    Blog ..|> Cloneable : implements
    
    %% 样式定义
    classDef controllerClass fill:#e3f2fd,stroke:#74b9ff
    classDef serviceClass fill:#f0f7ff,stroke:#a29bfe
    classDef modelClass fill:#e8f5ff,stroke:#6c5ce7
    classDef interfaceClass fill:#f8f9fa,stroke:#b2bec3
    classDef abstractClass fill:#fff3cd,stroke:#ffc107
    
    class BlogController,LLMController,ConfigController,ImageController controllerClass
    class BlogFileService,ConfigService serviceClass
    class Blog,Config,Message,BigModel,XModel,POSTMessage modelClass
    class FactoryInterface,StreamCallback interfaceClass
    class LLM abstractClass
        </div>

        <h3>3.2 类关系分析</h3>
        
        <div class="pattern-card">
            <h4>🎯 控制器层 (Controller Layer)</h4>
            <p><strong>核心职责</strong>：处理HTTP请求，协调业务逻辑，返回统一响应格式</p>
            <ul>
                <li><strong>BlogController</strong>：博客文章的CRUD操作</li>
                <li><strong>LLMController</strong>：AI大模型集成和流式响应</li>
                <li><strong>ConfigController</strong>：系统配置管理</li>
                <li><strong>ImageController</strong>：图片上传和管理</li>
            </ul>
        </div>
        
        <div class="pattern-card">
            <h4>🔧 服务层 (Service Layer)</h4>
            <p><strong>核心职责</strong>：封装业务逻辑，提供数据操作接口</p>
            <ul>
                <li><strong>BlogFileService</strong>：博客文件系统操作</li>
                <li><strong>ConfigService</strong>：配置文件读写管理</li>
            </ul>
        </div>
        
        <div class="pattern-card">
            <h4>📊 模型层 (Model Layer)</h4>
            <p><strong>核心职责</strong>：数据模型定义，业务实体封装</p>
            <ul>
                <li><strong>Blog</strong>：博客实体，实现Comparable和Cloneable接口</li>
                <li><strong>Config</strong>：系统配置实体</li>
                <li><strong>Message</strong>：统一响应包装类</li>
                <li><strong>POSTMessage</strong>：LLM请求消息封装</li>
            </ul>
        </div>
        
        <div class="pattern-card">
            <h4>🤖 LLM集成层 (LLM Integration Layer)</h4>
            <p><strong>核心职责</strong>：大语言模型集成，工厂模式实现多模型支持</p>
            <ul>
                <li><strong>LLM</strong>：抽象基类，模板方法模式</li>
                <li><strong>BigModel/XModel</strong>：具体LLM实现</li>
                <li><strong>FactoryInterface</strong>：工厂接口</li>
                <li><strong>StreamCallback</strong>：流式响应回调接口</li>
            </ul>
        </div>        <h3>3.3 LLM集成流程架构</h3>        <div class="mermaid">
flowchart TB
    %% 控制层
    LC["`**LLMController**<br/>🎛️ 请求控制`"]
    
    %% 工厂层
    FI["`**FactoryInterface**<br/>🏭 工厂接口`"]
    BMF["`**BigModelFactory**`"]
    XMF["`**XModelFactory**`"]
    
    %% 模型层
    LLMC["`**LLM抽象类**<br/>📋 通用模板`"]
    BM["`**BigModel**`"]
    XM["`**XModel**`"]
    
    %% 外部服务
    API1["`**智谱AI**`"]
    API2["`**X-Model**`"]
    
    %% 连接关系
    LC --> FI
    LC --> LLMC
    
    FI --> BMF
    FI --> XMF
    
    BMF --> BM
    XMF --> XM
    
    LLMC -.-> BM    LLMC -.-> XM
    
    BM --> API1
    XM --> API2
    
    %% 样式定义
    classDef controllerStyle fill:#e3f2fd,stroke:#74b9ff
    classDef factoryStyle fill:#f0f7ff,stroke:#a29bfe
    classDef modelStyle fill:#e8f5ff,stroke:#6c5ce7
    classDef externalStyle fill:#f8f9fa,stroke:#b2bec3
    
    class LC controllerStyle
    class FI,BMF,XMF factoryStyle
    class LLMC,BM,XM modelStyle
    class API1,API2 externalStyle
        </div>
    </div>

    <div class="section">
        <h2>4. 设计模式分析</h2>
        
        <h3>4.1 核心设计模式</h3>
        
        <div class="pattern-card">
            <h4>1. MVC (Model-View-Controller) 模式</h4>
            <p><strong>实现位置</strong>：整个系统架构</p>
            <p><strong>具体体现</strong>：</p>
            <ul>
                <li><strong>Model</strong>：Blog, Message, Config等实体类</li>
                <li><strong>View</strong>：RESTful API响应（JSON格式）</li>
                <li><strong>Controller</strong>：各种Controller类处理请求</li>
            </ul>
            <p><strong>解决问题</strong>：分离关注点，提高代码可维护性和可扩展性</p>
        </div>
        
        <div class="pattern-card">
            <h4>2. 工厂模式 (Factory Pattern)</h4>
            <p><strong>实现位置</strong>：LLM模块</p>
            <p><strong>具体体现</strong>：</p>
            <ul>
                <li><strong>FactoryInterface</strong>：工厂接口</li>
                <li><strong>BigModelFactory, XModelFactory</strong>：具体工厂实现</li>
                <li><strong>BigModel, XModel</strong>：具体产品</li>
            </ul>
            <p><strong>解决问题</strong>：封装对象创建逻辑，支持多种LLM实现的动态切换</p>
        </div>
        
        <div class="pattern-card">
            <h4>3. 模板方法模式 (Template Method Pattern)</h4>
            <p><strong>实现位置</strong>：LLM抽象类</p>
            <p><strong>具体体现</strong>：</p>
            <ul>
                <li><strong>LLM抽象类</strong>：定义通用属性和抽象方法callLLM()</li>
                <li><strong>BigModel, XModel</strong>：实现具体的API调用逻辑</li>
            </ul>
            <p><strong>解决问题</strong>：定义算法骨架，允许子类重写特定步骤</p>
        </div>
        
        <div class="pattern-card">
            <h4>4. 观察者模式 (Observer Pattern)</h4>
            <p><strong>实现位置</strong>：流式响应机制</p>
            <p><strong>具体体现</strong>：</p>
            <ul>
                <li><strong>StreamCallback接口</strong>：观察者接口</li>
                <li><strong>SseEmitter</strong>：被观察者，推送数据到客户端</li>
            </ul>
            <p><strong>解决问题</strong>：实现异步数据流处理和实时推送</p>
        </div>
        
        <div class="pattern-card">
            <h4>5. 单例模式 (Singleton Pattern)</h4>
            <p><strong>实现位置</strong>：配置管理</p>
            <p><strong>具体体现</strong>：</p>
            <ul>
                <li><strong>ConfigService</strong>：通过Spring的@Bean注解实现单例</li>
                <li><strong>Config对象</strong>：全局唯一的配置实例</li>
            </ul>
            <p><strong>解决问题</strong>：确保配置的一致性和资源的合理使用</p>
        </div>
        
        <div class="pattern-card">
            <h4>6. 建造者模式 (Builder Pattern)</h4>
            <p><strong>实现位置</strong>：Blog对象构造</p>
            <p><strong>具体体现</strong>：</p>
            <ul>
                <li><strong>Blog类</strong>：提供多种构造方法</li>
                <li><strong>不同场景</strong>：创建、查询、解析文件等不同构造方式</li>
            </ul>
            <p><strong>解决问题</strong>：简化复杂对象的创建过程</p>
        </div>
        
        <div class="pattern-card">
            <h4>7. 策略模式 (Strategy Pattern)</h4>
            <p><strong>实现位置</strong>：LLM类型选择</p>
            <p><strong>具体体现</strong>：</p>
            <ul>
                <li><strong>LLM接口</strong>：策略接口</li>
                <li><strong>BigModel, XModel</strong>：具体策略实现</li>
                <li><strong>LLMController</strong>：上下文类，根据参数选择策略</li>
            </ul>
            <p><strong>解决问题</strong>：算法族的封装，支持运行时策略切换</p>
        </div>
    </div>

    <div class="section">
        <h2>5. RESTful API设计</h2>
        
        <h3>5.1 API设计原则</h3>
        <div class="advantages">
            <p><strong>资源导向</strong>：以资源为中心设计URL，如 /api/blogs</p>
            <p><strong>HTTP方法语义化</strong>：GET(查询)、POST(创建)、PUT/PATCH(更新)、DELETE(删除)</p>
            <p><strong>状态码规范</strong>：合理使用HTTP状态码表示操作结果</p>
            <p><strong>统一响应格式</strong>：使用Message对象封装响应数据</p>
        </div>
        
        <h3>5.2 API结构设计</h3>        <div class="mermaid">
flowchart LR
    A["`**博客API**<br/>/api/blogs`"] --> B["`**获取列表**<br/>GET /lists`"]
    A --> C["`**获取内容**<br/>GET /{year}/{month}/{day}/{filename}/`"]
    A --> D["`**更新信息**<br/>GET /{year}/{month}/{day}/{filename}/updateinfo`"]
    A --> E["`**更新内容**<br/>POST /{year}/{month}/{day}/{filename}/updatecontent`"]
    A --> F["`**添加博客**<br/>GET /add`"]
    A --> G["`**删除博客**<br/>GET /{year}/{month}/{day}/{filename}/delete/`"]
    
    H["`**配置API**<br/>/api/config`"] --> I["`**获取配置**<br/>GET /`"]
    H --> J["`**更新配置**<br/>POST /update`"]
    
    K["`**LLM API**<br/>/llm`"] --> L["`**设置类型**<br/>GET /set`"]
    K --> M["`**生成博客**<br/>POST /generate`"]
    K --> N["`**扩展内容**<br/>POST /expand`"]
        </div>
        
        <h3>5.3 统一响应格式</h3>
        <div class="code-block">
{
    "code": 0,        // 0-成功, 1-失败
    "data": {...},    // 响应数据
    "message": "..."  // 提示信息
}
        </div>
    </div>

    <div class="section">
        <h2>6. 系统设计优势</h2>
        
        <h3>6.1 架构优势</h3>
        <div class="advantages">
            <h4>高内聚低耦合</h4>
            <p>各层职责分明，模块间依赖关系清晰，便于维护和扩展</p>
            
            <h4>可扩展性强</h4>
            <p>工厂模式支持新LLM的动态添加，配置系统支持运行时修改</p>
            
            <h4>安全性考虑</h4>
            <p>文件路径解析包含安全检查，防止路径遍历攻击</p>
            
            <h4>异步处理</h4>
            <p>使用ExecutorService和SseEmitter实现异步响应，提升用户体验</p>
        </div>
        
        <h3>6.2 代码质量</h3>
        <ul>
            <li><strong>日志记录</strong>：完善的日志系统，便于调试和监控</li>
            <li><strong>异常处理</strong>：统一的异常处理机制，提高系统稳定性</li>
            <li><strong>配置外部化</strong>：支持外部配置文件，便于部署和管理</li>
            <li><strong>代码注释</strong>：详细的JavaDoc注释，便于代码理解和维护</li>
        </ul>
    </div>

    <div class="section">
        <h2>7. 系统流程图</h2>
        
        <h3>7.1 博客文章管理流程</h3>        <div class="mermaid">
sequenceDiagram
    participant C as 客户端
    participant BC as BlogController
    participant BFS as BlogFileService
    participant FS as 文件系统
    
    C->>BC: GET /api/blogs/lists
    BC->>BFS: listPostFilenames()
    BFS->>FS: 扫描.md文件
    FS-->>BFS: 文件列表
    BFS->>BFS: 解析文件内容创建Blog对象
    BFS-->>BC: List Blog
    BC-->>C: Message(0, blogList, null)
    
    C->>BC: GET /api/blogs/{year}/{month}/{day}/{filename}/
    BC->>BC: searchBydata(tmpblog)
    BC->>BFS: blog.loadContent()
    BFS->>FS: 读取文件内容
    FS-->>BFS: 文件内容
    BFS-->>BC: 博客内容
    BC-->>C: Message(0, blogClone, null)
        </div>
        
        <h3>7.2 LLM集成流程</h3>        <div class="mermaid">
sequenceDiagram
    participant C as 客户端
    participant LC as LLMController
    participant F as LLMFactory
    participant LLM as LLM实例
    participant API as 外部LLM_API
    
    C->>LC: GET /llm/set?llmType=XModel
    LC->>F: XModelFactory.createLLM()
    F-->>LC: XModel实例
    
    C->>LC: POST /llm/generate (SSE)
    LC->>LLM: callLLM(prompt, content, callback)
    LLM->>API: HTTP请求
    API-->>LLM: 流式响应
    LLM->>LC: StreamCallback.onData()
    LC-->>C: SSE数据推送
        </div>
    </div>

    <div class="section">
        <h2>8. 配置管理设计</h2>
        
        <h3>8.1 配置管理架构</h3>        <div class="mermaid">
graph TD
    A[应用启动] --> B[ConfigService.loadConfig]
    B --> C{配置文件存在?}
    C -->|否| D[创建默认配置]
    C -->|是| E[加载现有配置]
    E --> F{配置完整性检查}
    F -->|不完整| G[补充缺失配置]
    F -->|完整| H[配置加载完成]
    D --> I[保存配置到文件]
    G --> I
    I --> H
    H --> J["@Bean Config对象"]
    J --> K[注入到其他组件]
        </div>
        
        <h3>8.2 配置特性</h3>
        <ul>
            <li><strong>自动初始化</strong>：首次启动自动创建默认配置</li>
            <li><strong>动态更新</strong>：支持运行时配置修改和保存</li>
            <li><strong>完整性检查</strong>：启动时验证配置完整性</li>
            <li><strong>回滚机制</strong>：配置更新失败时自动回滚</li>
        </ul>
    </div>

    <div class="summary-box">
        <h2>总结</h2>
        <p>该博客管理系统采用了成熟的<strong>Spring Boot + MVC</strong>架构，合理运用了多种设计模式，实现了<strong>高内聚低耦合</strong>的系统设计。系统具有良好的<strong>可扩展性</strong>、<strong>可维护性</strong>和<strong>安全性</strong>，RESTful API设计规范，支持现代化的流式响应和异步处理，是一个设计良好的企业级应用。</p>
    </div>

    <div class="footer">
        <p>博客管理系统架构设计报告 | 生成时间: 2025年6月9日</p>
    </div>    <script>        if (typeof mermaid !== 'undefined') {
            mermaid.initialize({
                startOnLoad: false,
                theme: 'default',
                flowchart: {
                    nodeSpacing: 80,
                    rankSpacing: 100,
                    padding: 20
                },
                themeVariables: {
                    primaryColor: '#e3f2fd',
                    primaryTextColor: '#2c3e50',
                    primaryBorderColor: '#74b9ff',
                    lineColor: '#a29bfe',
                    secondaryColor: '#f8f9fa',
                    tertiaryColor: '#f0f7ff',
                    background: '#ffffff',
                    mainBkg: '#e3f2fd',
                    secondBkg: '#f0f7ff',
                    tertiaryBkg: '#ffffff'
                }
            });
            // 显式调用 mermaid.run() 来渲染所有 class="mermaid" 的元素
            // 此脚本位于 body 末尾，因此 DOM 应该已准备就绪。
            mermaid.run();
        } else {
            // 此消息将显示在浏览器的开发者控制台中
            console.error("Mermaid.js library not loaded or failed to initialize.");
        }
    </script>
</body>
</html>
