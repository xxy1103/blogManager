<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>博客管理系统设计模式分析报告</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        
        h2 {
            color: #34495e;
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin-top: 40px;
            margin-bottom: 20px;
        }
        
        h3 {
            color: #2980b9;
            margin-top: 25px;
        }
        
        .pattern-section {
            margin-bottom: 50px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #fafafa;
        }
        
        .advantages {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .features {
            background-color: #cce5ff;
            border: 1px solid #99d6ff;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .problems {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .code-snippet {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        .mermaid {
            text-align: center;
            margin: 20px 0;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
        }
        
        ul, ol {
            padding-left: 25px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .highlight {
            background-color: #ffffcc;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .summary {
            background-color: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 30px 0;
            border-radius: 0 5px 5px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>博客管理系统设计模式分析报告</h1>
        
        <div class="summary">
            <h3>📋 报告概要</h3>
            <p>本报告基于博客管理系统的实际代码，深入分析了六种重要设计模式的应用场景、实现方式及其带来的优势。通过Mermaid图表直观展示了各种模式的工作流程和类关系，为理解和学习设计模式提供了实际案例参考。</p>
        </div>

        <div class="pattern-section">
            <h2>🏗️ 1. MVC (Model-View-Controller) 模式</h2>
            
            <h3>💡 在项目中的应用</h3>
            <p>博客管理系统严格遵循Spring Boot的MVC架构模式，将应用程序分为三个核心组件：</p>
            
            <div class="mermaid">
                graph TB
                    subgraph "Controller Layer"
                        BC[BlogController]
                        LC[LLMController]
                        CC[ConfigController]
                        IC[ImageController]
                    end
                    
                    subgraph "Service/Repository Layer"
                        BFS[BlogFileService]
                        CS[ConfigService]
                        LLM[LLM Services]
                    end
                    
                    subgraph "Model Layer"
                        Blog[Blog Model]
                        Config[Config Model]
                        Message[Message Model]
                    end
                    
                    subgraph "View Layer"
                        API[REST API Response]
                        JSON[JSON Data]
                    end
                    
                    BC --> BFS
                    LC --> LLM
                    CC --> CS
                    
                    BFS --> Blog
                    CS --> Config
                    
                    BC --> API
                    LC --> JSON
                    CC --> JSON
                    IC --> JSON
                    
                    style BC fill:#e1f5fe
                    style LC fill:#e1f5fe
                    style BFS fill:#f3e5f5
                    style Blog fill:#e8f5e8
                    style API fill:#fff3e0
            </div>
            
            <div class="code-snippet">
                <strong>Controller 层示例 (BlogController.java):</strong><br>
                @RestController<br>
                @RequestMapping("/api/blogs")<br>
                public class BlogController {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;@Autowired<br>
                &nbsp;&nbsp;&nbsp;&nbsp;private BlogFileService blogFileService;<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;@GetMapping("/lists")<br>
                &nbsp;&nbsp;&nbsp;&nbsp;public Message listBlogFilenames() {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 调用Service层处理业务逻辑<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.blogList = blogFileService.listPostFilenames();<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Message(0, blogList, null);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                }
            </div>
            
            <div class="advantages">
                <h4>✅ 优势</h4>
                <ul>
                    <li><strong>关注点分离</strong>：业务逻辑、数据模型和表示层完全解耦</li>
                    <li><strong>可维护性</strong>：修改某一层不会影响其他层的实现</li>
                    <li><strong>可测试性</strong>：每层都可以独立进行单元测试</li>
                    <li><strong>团队协作</strong>：前后端开发人员可以并行工作</li>
                    <li><strong>代码复用</strong>：Service层可以被多个Controller复用</li>
                </ul>
            </div>
            
            <div class="features">
                <h4>🔧 特点</h4>
                <ul>
                    <li><strong>单一职责</strong>：每个组件只负责自己的核心功能</li>
                    <li><strong>松耦合</strong>：通过依赖注入实现组件间的松耦合</li>
                    <li><strong>层次清晰</strong>：明确的分层结构便于理解和维护</li>
                    <li><strong>RESTful设计</strong>：Controller提供标准的REST API接口</li>
                </ul>
            </div>
            
            <div class="problems">
                <h4>🎯 解决的问题</h4>
                <ul>
                    <li><strong>代码混乱</strong>：避免将业务逻辑、数据访问和视图渲染混在一起</li>
                    <li><strong>难以维护</strong>：通过分层降低系统复杂度</li>
                    <li><strong>代码重复</strong>：Service层复用避免重复的业务逻辑</li>
                    <li><strong>测试困难</strong>：分层设计使得单元测试更容易进行</li>
                </ul>
            </div>
        </div>

        <div class="pattern-section">
            <h2>🏭 2. 工厂模式 (Factory Pattern)</h2>
            
            <h3>💡 在项目中的应用</h3>
            <p>系统使用工厂模式来创建不同类型的LLM (Large Language Model) 实例，支持XModel和BigModel两种不同的AI服务提供商：</p>
            
            <div class="mermaid">
                graph TB
                    subgraph "Factory Pattern"
                        FI[FactoryInterface]
                        XMF[XModelFactory]
                        BMF[BigModelFactory]
                        
                        FI -.implements.-> XMF
                        FI -.implements.-> BMF
                    end
                    
                    subgraph "Products"
                        LLM[LLM Abstract Class]
                        XM[XModel]
                        BM[BigModel]
                        
                        LLM -.extends.-> XM
                        LLM -.extends.-> BM
                    end
                    
                    subgraph "Client"
                        LLMC[LLMController]
                        Config[Config]
                    end
                    
                    LLMC --> XMF
                    LLMC --> BMF
                    XMF --> XM
                    BMF --> BM
                    
                    Config --> XMF
                    Config --> BMF
                    
                    style FI fill:#ffecb3
                    style XMF fill:#c8e6c9
                    style BMF fill:#c8e6c9
                    style LLM fill:#e1bee7
                    style XM fill:#ffcdd2
                    style BM fill:#ffcdd2
            </div>
            
            <div class="code-snippet">
                <strong>工厂接口定义 (FactoryInterface.java):</strong><br>
                public interface FactoryInterface {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;LLM createLLM();<br>
                }<br>
                <br>
                <strong>具体工厂实现 (BigModelFactory.java):</strong><br>
                public class BigModelFactory implements FactoryInterface {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;private String APIKey;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;private final String APIUrl = "https://open.bigmodel.cn/api/paas/v4/chat/completions";<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;public BigModelFactory(Config config) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.APIKey = config.getBigmodelAPIKey();<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;@Override<br>
                &nbsp;&nbsp;&nbsp;&nbsp;public LLM createLLM() {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new BigModel(APIKey, APIUrl, model);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                }
            </div>
            
            <div class="advantages">
                <h4>✅ 优势</h4>
                <ul>
                    <li><strong>扩展性</strong>：添加新的LLM提供商只需新增工厂类，无需修改现有代码</li>
                    <li><strong>封装创建逻辑</strong>：隐藏复杂的对象创建过程和参数配置</li>
                    <li><strong>统一接口</strong>：客户端通过统一的接口获取不同类型的LLM实例</li>
                    <li><strong>降低耦合</strong>：客户端代码不直接依赖具体的LLM实现类</li>
                </ul>
            </div>
            
            <div class="features">
                <h4>🔧 特点</h4>
                <ul>
                    <li><strong>多态性</strong>：基于接口的设计支持运行时切换不同的工厂</li>
                    <li><strong>配置驱动</strong>：通过Config对象传递不同的API密钥和配置</li>
                    <li><strong>延迟实例化</strong>：只有在需要时才创建LLM实例</li>
                    <li><strong>参数封装</strong>：将复杂的API参数封装在工厂内部</li>
                </ul>
            </div>
            
            <div class="problems">
                <h4>🎯 解决的问题</h4>
                <ul>
                    <li><strong>硬编码依赖</strong>：避免在客户端代码中硬编码具体的LLM类型</li>
                    <li><strong>创建复杂性</strong>：简化LLM实例的创建过程</li>
                    <li><strong>配置管理</strong>：集中管理不同LLM的配置参数</li>
                    <li><strong>类型切换</strong>：运行时动态选择不同的AI服务提供商</li>
                </ul>
            </div>
        </div>

        <div class="pattern-section">
            <h2>📋 3. 模板方法模式 (Template Method Pattern)</h2>
            
            <h3>💡 在项目中的应用</h3>
            <p>LLM抽象类定义了调用AI服务的基本流程和通用属性，具体的LLM实现类重写关键的调用方法：</p>
            
            <div class="mermaid">
                graph TB
                    subgraph "Template Method Pattern"
                        LLM[LLM Abstract Class]
                        BM[BigModel]
                        XM[XModel]
                        
                        LLM -.template method.-> BM
                        LLM -.template method.-> XM
                    end
                    
                    subgraph "Common Steps"
                        CS1[Set API Parameters]
                        CS2[Prepare Messages]
                        CS3[Handle Streaming]
                        CS4[Error Processing]
                    end
                    
                    subgraph "Variable Steps"
                        VS1[API Call Implementation]
                        VS2[Response Parsing]
                        VS3[Platform Specific Logic]
                    end
                    
                    LLM --> CS1
                    LLM --> CS2
                    LLM --> CS3
                    LLM --> CS4
                    
                    BM --> VS1
                    BM --> VS2
                    XM --> VS1
                    XM --> VS2
                    
                    style LLM fill:#ffecb3
                    style BM fill:#c8e6c9
                    style XM fill:#c8e6c9
                    style CS1 fill:#e3f2fd
                    style CS2 fill:#e3f2fd
                    style VS1 fill:#ffebee
                    style VS2 fill:#ffebee
            </div>
            
            <div class="code-snippet">
                <strong>抽象模板类 (LLM.java):</strong><br>
                public abstract class LLM {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;// 通用属性和方法<br>
                &nbsp;&nbsp;&nbsp;&nbsp;private String APIKey;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;private String APIUrl;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;private String model;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;protected ArrayList&lt;POSTMessage&gt; messagesArray;<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;// 构造函数定义通用初始化流程<br>
                &nbsp;&nbsp;&nbsp;&nbsp;public LLM(String APIKey, String APIUrl, String model) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.APIKey = APIKey;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.APIUrl = APIUrl;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.model = model;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.messagesArray = new ArrayList&lt;&gt;();<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;// 抽象方法，子类必须实现<br>
                &nbsp;&nbsp;&nbsp;&nbsp;public abstract void callLLM(String prompt, String content, StreamCallback callback);<br>
                }
            </div>
            
            <div class="advantages">
                <h4>✅ 优势</h4>
                <ul>
                    <li><strong>代码复用</strong>：通用的初始化逻辑和属性管理在基类中实现</li>
                    <li><strong>一致性</strong>：确保所有LLM实现都遵循相同的基本结构</li>
                    <li><strong>扩展性</strong>：新增LLM类型只需继承并实现抽象方法</li>
                    <li><strong>维护性</strong>：通用功能的修改只需在基类中进行</li>
                </ul>
            </div>
            
            <div class="features">
                <h4>🔧 特点</h4>
                <ul>
                    <li><strong>骨架定义</strong>：抽象类定义了LLM服务的基本骨架</li>
                    <li><strong>钩子方法</strong>：callLLM方法作为钩子方法由子类实现</li>
                    <li><strong>不变部分</strong>：公共属性和getter/setter方法保持不变</li>
                    <li><strong>可变部分</strong>：具体的API调用逻辑由子类定制</li>
                </ul>
            </div>
            
            <div class="problems">
                <h4>🎯 解决的问题</h4>
                <ul>
                    <li><strong>代码重复</strong>：避免在每个LLM实现中重复相同的基础代码</li>
                    <li><strong>结构不一致</strong>：统一不同LLM实现的基本结构</li>
                    <li><strong>维护困难</strong>：集中管理通用功能，便于维护和升级</li>
                    <li><strong>扩展复杂</strong>：简化新LLM类型的接入过程</li>
                </ul>
            </div>
        </div>

        <div class="pattern-section">
            <h2>👀 4. 观察者模式 (Observer Pattern)</h2>
            
            <h3>💡 在项目中的应用</h3>
            <p>通过StreamCallback接口实现观察者模式，处理LLM API的流式响应，实现实时数据推送：</p>
            
            <div class="mermaid">
                graph TB
                    subgraph "Observer Pattern"
                        SC[StreamCallback Interface]
                        LLM[LLM Subject]
                        LLMC[LLMController Observer]
                    end
                    
                    subgraph "Callback Methods"
                        OR[onResponse]
                        OE[onError]
                    end
                    
                    subgraph "Streaming Process"
                        API[LLM API Call]
                        STREAM[Stream Response]
                        NOTIFY[Notify Observers]
                        UPDATE[Update UI/Client]
                    end
                    
                    SC -.defines.-> OR
                    SC -.defines.-> OE
                    LLMC -.implements.-> SC
                    
                    LLM --> API
                    API --> STREAM
                    STREAM --> NOTIFY
                    NOTIFY --> OR
                    NOTIFY --> OE
                    OR --> UPDATE
                    
                    style SC fill:#ffecb3
                    style LLMC fill:#c8e6c9
                    style LLM fill:#e1bee7
                    style STREAM fill:#e3f2fd
                    style NOTIFY fill:#ffebee
            </div>
            
            <div class="code-snippet">
                <strong>观察者接口 (StreamCallback.java):</strong><br>
                public interface StreamCallback {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;/**<br>
                &nbsp;&nbsp;&nbsp;&nbsp; * 处理流式输出的回调方法<br>
                &nbsp;&nbsp;&nbsp;&nbsp; */<br>
                &nbsp;&nbsp;&nbsp;&nbsp;void onResponse(String chunk, boolean isDone);<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;/**<br>
                &nbsp;&nbsp;&nbsp;&nbsp; * 错误处理回调方法<br>
                &nbsp;&nbsp;&nbsp;&nbsp; */<br>
                &nbsp;&nbsp;&nbsp;&nbsp;void onError(String error);<br>
                }<br>
                <br>
                <strong>观察者实现 (LLMController.java):</strong><br>
                StreamCallback callback = new StreamCallback() {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;@Override<br>
                &nbsp;&nbsp;&nbsp;&nbsp;public void onResponse(String chunk, boolean isDone) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;responseText.append(chunk);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 实时处理流式数据<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;@Override<br>
                &nbsp;&nbsp;&nbsp;&nbsp;public void onError(String error) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.error("获取建议时发生错误: " + error);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                };
            </div>
            
            <div class="advantages">
                <h4>✅ 优势</h4>
                <ul>
                    <li><strong>实时响应</strong>：支持流式数据的实时处理和推送</li>
                    <li><strong>松耦合</strong>：LLM服务和响应处理逻辑完全解耦</li>
                    <li><strong>异步处理</strong>：支持异步的数据流处理</li>
                    <li><strong>错误处理</strong>：统一的错误通知机制</li>
                    <li><strong>扩展性</strong>：可以轻松添加多个观察者处理不同类型的响应</li>
                </ul>
            </div>
            
            <div class="features">
                <h4>🔧 特点</h4>
                <ul>
                    <li><strong>事件驱动</strong>：基于回调的事件驱动架构</li>
                    <li><strong>状态通知</strong>：通过isDone参数通知流处理状态</li>
                    <li><strong>错误传播</strong>：统一的错误传播机制</li>
                    <li><strong>接口约定</strong>：通过接口定义标准的通知协议</li>
                </ul>
            </div>
            
            <div class="problems">
                <h4>🎯 解决的问题</h4>
                <ul>
                    <li><strong>阻塞等待</strong>：避免同步等待长时间的AI响应</li>
                    <li><strong>用户体验</strong>：提供流式响应改善用户体验</li>
                    <li><strong>资源占用</strong>：减少长连接的资源占用</li>
                    <li><strong>响应处理</strong>：灵活处理不同类型的响应数据</li>
                </ul>
            </div>
        </div>

        <div class="pattern-section">
            <h2>🔒 5. 单例模式 (Singleton Pattern)</h2>
            
            <h3>💡 在项目中的应用</h3>
            <p>虽然项目中没有显式的单例类，但Spring框架的Bean管理实际上实现了单例模式。ConfigService、BlogFileService等服务类都是单例Bean：</p>
            
            <div class="mermaid">
                graph TB
                    subgraph "Spring Singleton Beans"
                        SC[Spring Container]
                        CS[ConfigService @Configuration]
                        BFS[BlogFileService @Service]
                        Config[Config Bean]
                        LLMC[LLMController @RestController]
                    end
                    
                    subgraph "Singleton Lifecycle"
                        CREATE[Bean Creation]
                        CACHE[Cache Instance]
                        INJECT[Dependency Injection]
                        REUSE[Reuse Instance]
                    end
                    
                    subgraph "Benefits"
                        MEMORY[Memory Efficiency]
                        STATE[Shared State]
                        CONSISTENCY[Data Consistency]
                    end
                    
                    SC --> CREATE
                    CREATE --> CS
                    CREATE --> BFS
                    CREATE --> Config
                    
                    CS --> CACHE
                    BFS --> CACHE
                    Config --> CACHE
                    
                    CACHE --> INJECT
                    INJECT --> LLMC
                    
                    INJECT --> REUSE
                    REUSE --> MEMORY
                    REUSE --> STATE
                    REUSE --> CONSISTENCY
                    
                    style SC fill:#ffecb3
                    style CS fill:#c8e6c9
                    style BFS fill:#c8e6c9
                    style Config fill:#e1bee7
                    style CACHE fill:#e3f2fd
                    style MEMORY fill:#e8f5e8
            </div>
            
            <div class="code-snippet">
                <strong>Spring管理的单例Bean (ConfigService.java):</strong><br>
                @Configuration<br>
                public class ConfigService {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;// Spring确保这个类只有一个实例<br>
                &nbsp;&nbsp;&nbsp;&nbsp;private Path configPath;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;private Config config;<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;@PostConstruct<br>
                &nbsp;&nbsp;&nbsp;&nbsp;public void loadConfig() {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 初始化配置，全局共享<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                }<br>
                <br>
                <strong>服务层单例 (BlogFileService.java):</strong><br>
                @Service<br>
                public class BlogFileService {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;// Spring容器管理的单例服务<br>
                &nbsp;&nbsp;&nbsp;&nbsp;private final Path storageLocation;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;private Config config;<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;@Autowired<br>
                &nbsp;&nbsp;&nbsp;&nbsp;public BlogFileService(Config config) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 依赖注入单例配置<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                }
            </div>
            
            <div class="advantages">
                <h4>✅ 优势</h4>
                <ul>
                    <li><strong>内存效率</strong>：减少对象创建，节省内存资源</li>
                    <li><strong>全局访问</strong>：提供全局唯一的配置和服务实例</li>
                    <li><strong>状态共享</strong>：在整个应用中共享配置和状态信息</li>
                    <li><strong>生命周期管理</strong>：Spring容器自动管理Bean的生命周期</li>
                    <li><strong>线程安全</strong>：Spring确保Bean创建过程的线程安全</li>
                </ul>
            </div>
            
            <div class="features">
                <h4>🔧 特点</h4>
                <ul>
                    <li><strong>容器管理</strong>：由Spring IoC容器负责单例管理</li>
                    <li><strong>懒加载</strong>：支持懒加载和提前初始化</li>
                    <li><strong>依赖注入</strong>：通过@Autowired实现依赖注入</li>
                    <li><strong>配置驱动</strong>：通过注解配置单例行为</li>
                </ul>
            </div>
            
            <div class="problems">
                <h4>🎯 解决的问题</h4>
                <ul>
                    <li><strong>资源浪费</strong>：避免重复创建相同的服务实例</li>
                    <li><strong>配置管理</strong>：全局统一的配置管理</li>
                    <li><strong>状态一致性</strong>：确保应用状态的一致性</li>
                    <li><strong>初始化开销</strong>：减少重复的初始化开销</li>
                </ul>
            </div>
        </div>

        <div class="pattern-section">
            <h2>🎯 6. 策略模式 (Strategy Pattern)</h2>
            
            <h3>💡 在项目中的应用</h3>
            <p>LLMController中根据用户选择动态切换不同的LLM服务提供商，体现了策略模式的应用：</p>
            
            <div class="mermaid">
                graph TB
                    subgraph "Strategy Pattern"
                        LLMC[LLMController Context]
                        LLM[LLM Strategy Interface]
                        BM[BigModel Strategy]
                        XM[XModel Strategy]
                    end
                    
                    subgraph "Strategy Selection"
                        INPUT[User Input]
                        SWITCH[Strategy Switch]
                        FACTORY[Factory Creation]
                    end
                    
                    subgraph "Algorithm Execution"
                        CALL[callLLM Method]
                        BIGAPI[BigModel API Logic]
                        XAPI[XModel API Logic]
                    end
                    
                    LLMC --> LLM
                    LLM -.implements.-> BM
                    LLM -.implements.-> XM
                    
                    INPUT --> SWITCH
                    SWITCH --> FACTORY
                    FACTORY --> BM
                    FACTORY --> XM
                    
                    BM --> CALL
                    XM --> CALL
                    CALL --> BIGAPI
                    CALL --> XAPI
                    
                    LLMC -.uses.-> BM
                    LLMC -.uses.-> XM
                    
                    style LLMC fill:#ffecb3
                    style LLM fill:#e1bee7
                    style BM fill:#c8e6c9
                    style XM fill:#c8e6c9
                    style SWITCH fill:#e3f2fd
                    style CALL fill:#ffebee
            </div>
            
            <div class="code-snippet">
                <strong>策略上下文 (LLMController.java):</strong><br>
                @RestController<br>
                public class LLMController {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;private LLM llm; // 策略接口引用<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;@RequestMapping("/set")<br>
                &nbsp;&nbsp;&nbsp;&nbsp;public void getLlm(@RequestParam String llmType) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (llmType) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case "XModel":<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XModelFactory factory = new XModelFactory(config);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;llm = factory.createLLM(); // 动态策略选择<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case "BigModel":<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BigModelFactory bigModelFactory = new BigModelFactory(config);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;llm = bigModelFactory.createLLM();<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;// 使用选定的策略<br>
                &nbsp;&nbsp;&nbsp;&nbsp;public void processRequest() {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;llm.callLLM(prompt, content, callback);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                }
            </div>
            
            <div class="advantages">
                <h4>✅ 优势</h4>
                <ul>
                    <li><strong>运行时切换</strong>：可以在运行时动态切换不同的AI服务提供商</li>
                    <li><strong>算法独立</strong>：不同LLM的实现算法完全独立</li>
                    <li><strong>易于扩展</strong>：添加新的LLM类型不需要修改现有代码</li>
                    <li><strong>消除条件语句</strong>：避免大量的if-else或switch语句</li>
                    <li><strong>测试友好</strong>：可以轻松测试不同的策略实现</li>
                </ul>
            </div>
            
            <div class="features">
                <h4>🔧 特点</h4>
                <ul>
                    <li><strong>策略封装</strong>：每个LLM实现都封装了特定的调用策略</li>
                    <li><strong>上下文无关</strong>：策略实现不依赖特定的上下文</li>
                    <li><strong>工厂结合</strong>：与工厂模式结合创建策略实例</li>
                    <li><strong>配置驱动</strong>：基于用户配置选择合适的策略</li>
                </ul>
            </div>
            
            <div class="problems">
                <h4>🎯 解决的问题</h4>
                <ul>
                    <li><strong>硬编码算法</strong>：避免将具体的LLM调用逻辑硬编码</li>
                    <li><strong>服务商锁定</strong>：避免被单一AI服务提供商锁定</li>
                    <li><strong>算法切换</strong>：简化不同AI服务之间的切换</li>
                    <li><strong>代码膨胀</strong>：避免因多种算法导致的代码膨胀</li>
                </ul>
            </div>
        </div>

        <div class="summary">
            <h2>📊 设计模式应用总结</h2>
            
            <table>
                <thead>
                    <tr>
                        <th>设计模式</th>
                        <th>应用场景</th>
                        <th>核心价值</th>
                        <th>代码位置</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>MVC模式</strong></td>
                        <td>整体架构分层</td>
                        <td>关注点分离，提高可维护性</td>
                        <td>Controller、Service、Model包</td>
                    </tr>
                    <tr>
                        <td><strong>工厂模式</strong></td>
                        <td>LLM实例创建</td>
                        <td>封装创建逻辑，支持多种AI服务</td>
                        <td>factory包下的工厂类</td>
                    </tr>
                    <tr>
                        <td><strong>模板方法</strong></td>
                        <td>LLM基础结构</td>
                        <td>代码复用，统一实现规范</td>
                        <td>LLM抽象类及其子类</td>
                    </tr>
                    <tr>
                        <td><strong>观察者模式</strong></td>
                        <td>流式响应处理</td>
                        <td>实时数据推送，异步处理</td>
                        <td>StreamCallback接口及实现</td>
                    </tr>
                    <tr>
                        <td><strong>单例模式</strong></td>
                        <td>Spring Bean管理</td>
                        <td>资源共享，全局配置管理</td>
                        <td>所有@Service、@Configuration类</td>
                    </tr>
                    <tr>
                        <td><strong>策略模式</strong></td>
                        <td>LLM服务选择</td>
                        <td>运行时算法切换，避免耦合</td>
                        <td>LLMController的策略选择逻辑</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>🎯 整体设计哲学</h3>
            <p>该博客管理系统的设计充分体现了<span class="highlight">SOLID原则</span>和<span class="highlight">设计模式</span>的最佳实践：</p>
            <ul>
                <li><strong>单一职责原则</strong>：每个类都有明确的单一责任</li>
                <li><strong>开闭原则</strong>：通过接口和抽象类支持扩展，拒绝修改</li>
                <li><strong>依赖倒置原则</strong>：依赖抽象而非具体实现</li>
                <li><strong>里氏替换原则</strong>：子类可以完全替换父类</li>
                <li><strong>接口隔离原则</strong>：接口设计精简，职责明确</li>
            </ul>
            
            <h3>🚀 未来扩展建议</h3>
            <ul>
                <li><strong>装饰器模式</strong>：为LLM服务添加缓存、日志、重试等功能</li>
                <li><strong>命令模式</strong>：将博客操作封装为命令，支持撤销和重做</li>
                <li><strong>责任链模式</strong>：构建请求处理链，支持复杂的业务流程</li>
                <li><strong>适配器模式</strong>：适配更多第三方AI服务接口</li>
            </ul>
        </div>
        
        <footer style="text-align: center; margin-top: 50px; padding-top: 20px; border-top: 1px solid #ddd; color: #666;">
            <p>📅 生成时间：2025年6月9日 | 🔧 基于博客管理系统代码分析</p>
        </footer>
    </div>

    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#3498db',
                primaryTextColor: '#2c3e50',
                primaryBorderColor: '#2980b9',
                lineColor: '#34495e',
                sectionBkgColor: '#ecf0f1',
                altSectionBkgColor: '#ffffff',
                gridColor: '#bdc3c7',
                tertiaryColor: '#f8f9fa'
            }
        });
    </script>
</body>
</html>
